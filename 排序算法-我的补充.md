<h2>从小到大排序</h2>

<!-- GFM-TOC -->
* [交换排序](#交换排序)
  * [冒泡排序](#冒泡排序)
  * [快速排序](#快速排序)
* [选择排序](#选择排序)
  * [简单选择排序](#简单选择排序)
  * [堆排序](#堆排序)
* [插入排序](#插入排序)
  * [简单插入排序](#简单插入排序)
  * [希尔排序](#希尔排序)
* [归并排序](#归并排序)
  * [二路归并排序](#二路归并排序)
  * [多路归并排序](#多路归并排序)
* [参考文献](#参考文献)
<!-- GFM-TOC -->

# 交换排序
## 冒泡排序
- 从头开始，相邻值两两比较，逆序则交换，结果为最值被放到最后
```java
public static void BubbleSort(int[] arr)
{
  for(int i=0;i<arr.length-1;i++)     //i：比较的趟数，也是已经确定好位置的数字的个数
                                      //注意，i的最大值是arr.length-2，即只需要确定arr.length-1个数的位置
    for(int j=0;j<arr.length-1-i;j++) //j：正在比较的数的角标
      if(arr[j]>arr[j+1]){            //j控制的内层循环才是冒泡的核心，思考时，应该先想内循环再想外循环
        int temp = arr[j];  
        arr[j] = arr[j+1];
        arr[j+1] = temp;
      }
}
```
## 快速排序
- 设基准，分两组；递归地对两组分别排序
- 当然，利用该思想还可以用别的代码实现，但是一般都采用这种（可能这样比较优秀）
```java
public static void quickSort(int[] arr){
    qSort(arr,0,arr.length-1);
}
//递归地分别对两组排序
public static void qSort(int[] arr, int low, int high){
    int mid = partition(arr,low,high); //根据基准，分成两组
    qSort(arr,low,mid-1);  //对左边，再根据基准分成左小右大的两组
    qSort(arr,min+1,high); //对右边，再根据基准分成左小右大的两组
}
//设基准，分两组，左边都小于等于基准，右边都大于等于基准
public static int partition(int[] arr, int low, int high){
    int pivot = arr[low];   //将基准设为比较部分（从arr[low]到arr[high]）的第一个数，同时arr[low]的位置可以认为是空，因为其值已经被记录在pivot中
    while(low<high){  
        while(low<high && pivot<=arr[high]) high--; //满足右边都>=基准则不动
        arr[low]=arr[high]; //右边有<基准的，将右边这个数，放到基准的左边的空位置,同时，此时的arr[high]的位置可以被任意占用，因为其值已经被记录在arr[low]中
        while(low<high && pivot>=arr[low]) low++;  //满足左边都<=基准则不动
        arr[high]=arr[low]; //左边有>基准的，将左边这个数，放到基准的右边的空位置,同时，此时的arr[low]的位置可以被任意占用，因为其值已经被记录在arr[high]中
    }
    array[low]=pivot;       //跳出循环时，low==high
    return low;
}
```
# 选择排序
## 简单选择排序
- 找到最小（大）的，将其添加到前面的有序序列中，即和有序序列后面一个元素交换。
```java
public static void selectionSort(int[] arr){	
	for(int i=0; i<arr.length-1;i++){
		int min = i;    //注意，应该是记录位置，而不是记录值
		for(int j=i; j<arr,length; j++)
			if(arr[j]<arr[min])
				min = j;
		temp = arr[i];
		arr[i] = arr[min];
		arr[min] = temp;		
	}
}
```
## 堆排序
# 插入排序
## 简单插入排序

## 希尔排序
- 选择一个降序序列t1，t2，…，tk（tk=1）
- 从i=1开始，将数组中间隔为ti的数据分为一组，每组进行简单插入排序，直至i=k，即以1为间隔，也就是整个数组，进行插入排序
- 
```java

```
# 归并排序
## 二路归并排序
- 先使子序列有序，再将已有序的子序列合并，递归实现
- 若将两个有序表合并成一个有序表，称为2-路归并：递归地将左右两边分别归并排序；将左右两个处理好的部分，归并在一起。
```java
public static void mergeSort(int[] arr){
    mSort(arr,0,arr.length-1);
}
//递归地将左右两部分进行排序
public static void mSort(int[] arr, int low, int high){
    if(high>low){
    	int mid = (high+low)/2;
        mSort(arr,low,mid);        // 左边归并排序
	mSort(arr, mid + 1, high); // 右边归并排序
	merge(arr, low, high, mid);// 左右两边归并
    }
}
//将已经排好序的两部分进行合并
public static void merge(int[] arr, int low, int high, int mid){
    int[] array_temp = new int[high-low+1]; //用一个空的临时数组存放排好序的部分
    int i = low;   //用来跟踪左边排好序的数组脚标
    int j = mid+1; //用来跟踪右边排好序的数组脚标
    int k = 0;     //用来跟踪空的临时数组脚标
    while(i<=mid && j<=high) //谁小放谁，直到某个数组全部放进临时数组
        if(arr[i]<arr[j])
            array_temp[k++] = arr[i++]
        else
	    array_temp[k++] = array[j++];
	//处理还没全部放入临时数组的那个数组的剩余部分
	while (j <= high) //如果是右边的数组还没全部放进去
	    array_temp[k++] = array[j++];
	while (i <= mid)  //如果是左边的数组还没全部放进去
	    array_temp[k++] = array[i++];
	//将排好序的临时数组中的值赋到原数组中
	for (int x = 0; x < high - low + 1; x++)
	    array[low + x] = array_temp[x];
}
```

## 多路归并排序



# 参考文献

https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F 希尔排序
