[toc]
从小到大排序
# 冒泡排序
- 从头开始，相邻值两两比较，逆序则交换，结果为最值被放到最后
```java
public static void BubbleSort(int[] arr)
{
  for(i=0;i<arr.length-1;i++) //i：比较的趟数，也是已经确定好位置的数字的个数
                            //注意，i的最大值是arr.length-2，即只需要确定arr.length-1个数的位置
    //j控制的内层循环才是冒泡的核心，思考时，应该先想内循环再想外循环
    for(j=0;j<arr.length-1-i;j++) //j：正在比较的数的角标
      if(arr[j]>arr[j+1]){ //交换
        int temp = arr[j];  
        arr[j] = arr[j+1];
        arr[j+1] = temp;
      }
}
```
# 快速排序
- 设基准，分两组；递归地对两组分别排序
```java
public static void quickSort(int[] arr){
    qSort(arr,0,arr.length-1);
}
//递归地分别对两组排序
public static void qSort(int[] arr, int low, int high){
    int mid = partition(arr,low,high); //根据基准，分成两组
    qSort(arr,low,mid-1);  //对左边，再根据基准分成左小右大的两组
    qSort(arr,min+1,high); //对右边，再根据基准分成左小右大的两组
}
//设基准，分两组，左边都小于等于基准，右边都大于等于基准
public static int partition(int[] arr, int low, int high){
    int pivot = arr[low]; //将基准设为比较部分（从arr[low]到arr[high]）的第一个数，同时arr[low]的位置可以认为是空，因为其值已经被记录在pivot中
    while(low<high){  
        while(low<high && pivot<=arr[high]) high--; //满足右边都>=基准则不动
        arr[low]=arr[high]; //右边有<基准的，将右边这个数，放到基准的左边的空位置,同时，此时的arr[high]的位置可以被任意占用，因为其值已经被记录在arr[low]中
        while(low<high && pivot>=arr[low]) low++;  //满足左边都<=基准则不动
        arr[high]=arr[low]; //左边有>基准的，将左边这个数，放到基准的右边的空位置,同时，此时的arr[low]的位置可以被任意占用，因为其值已经被记录在arr[high]中
    }
    array[low]=pivot;//跳出循环时，low==high
    return low;
}
```
